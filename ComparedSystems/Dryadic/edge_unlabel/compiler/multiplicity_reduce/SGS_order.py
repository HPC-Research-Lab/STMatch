from sympy.combinatorics import Permutation
from sympy.combinatorics.generators import symmetric
from copy import copy
from utils import list_of_set

# undirected edge
def jerrums_edge(perm):
    if perm.is_Identity:
        return (0,0)
    # have to make sure the permutation is
    return (perm.min(),perm.min()^perm)

# DSU-type structure that maps from an element to a structure like the follows:
# Doing both path compression and union by rank would be inefficient,
# As the sequence used is at least O(n^2) find operations, so it's
# { parent: direct parent, self if root, is necessarily smaller than self
#   perm:   a permutation with jerrums_edge (parent[self],self)
#           Is the identity permutation if self is root
# }
def DSU_create(size):
    # construct a DSU structure
    DSU = [0]*size
    for i in range(0,size):
        DSU[i] = {'parent':i,'perm':Permutation(size)}
    return DSU

#inner jerrum's loop
#returns either a new generator, or identity.
def jerrum_inner(D, perm):
    #check if identity
    if perm.is_Identity:
        return perm
    # Find the jerrum's edge
    a = perm.min()
    b = a^perm
    
    ra = DSU_parent(D,a)
    rb = DSU_parent(D,b)
    if ra is rb:
        # Make a new permutation to test on
        # note that a<b
        # a['perm'] maps r to a, perm maps a to b,  ~b['perm'] maps b to r
        # new permutation that still generates has larger first move
        return jerrum_inner(D,D[a]['perm'] * perm * ~D[b]['perm'])
    if ra > rb:
        # ra > rb, want to get something mapping rb to ra to put into ra
        D[ra]['parent'] = rb
        #           rb-> b    b->a      a->ra
        D[ra]['perm'] = D[b]['perm'] * ~perm * ~D[a]['perm']
    else:    
        # ra < rb, want to get something mapping ra to rb to put into rb
        D[rb]['parent'] = ra
        #           ra-> a    a->b      b->rb
        D[rb]['perm'] = D[a]['perm'] * perm * ~D[b]['perm']
        # perm adds something.
    return perm 
    
def DSU_parent(D,a):
    if D[a]['parent'] is a:
        return a
    par=DSU_parent(D,D[a]['parent'])
    # root is par
    #           take 'par' to D[a]['parent']    D[a]['parent'] to perm
    D[a]['perm'] = D[D[a]['parent']]['perm']           * D[a]['perm']
    D[a]['parent'] = par
    return par

# takes a python generator of generators of a subgroup of S_n, returns at most (n-1) generators
def jerrums(gens,n):
    # use a DSU to test for cycles in a graph of them.
    res = []
    DSU = DSU_create(n)
    # go through the list
    # print( type(DSU))
    # print(type(DSU_size))
    for perm in gens:
        # 
        # only doesn't form a new cycle if they are not already joined.
        perm_new = jerrum_inner(DSU,perm)
        if not perm_new.is_Identity:
            res.append(perm_new)
    return res

# returns all x in the orbit of root, in the form of a
# dictionary keyed by x, valued as a permutation in the
# group generated by gens that maps root to x.
# might be able to improve memory consumption by yielding pairs
def find_prop(root, gens,n):
    
    res = {}
    vis = []
    vis.append(root)
    res[root] = Permutation(size=n)
    while len(vis) > 0:
        x = vis.pop()
        for y in gens:
            if x^y not in res:
                res[x^y] = res[x]*y
                vis.append(x^y)
    return res

# schreier_generator
def schreier_generator(mapping, gens):
    # generates all the schreier generators
    # t_i*s *t_{s^i}
    for t in mapping:
        for s in gens:
            yield mapping[t]*s*~mapping[t^s]
            
# lazy from a set of generators
def lazy_SGS( autogen, n):
    # based on ideas in https://www.m8j.net/data/List/Files-118/Documentation.pdf
    olds = jerrums(autogen,n)
    b_to_test = 0

    order = list_of_set(n)
    while len(olds)>0 and b_to_test < n:
        # keep going
        # find all reachable from b_to_test under olds
        # run a BFS from b_to_test to all
        mappers = find_prop(b_to_test, olds, n)
        # generate the Schreier generators
        olds = jerrums(schreier_generator(mappers,olds),n)
        for x in mappers:
            if x is not b_to_test:
                order[b_to_test].add(x)
        b_to_test += 1
    return order 

def lazy_SGS_parent(autogen,n):
    
    # based on ideas in https://www.m8j.net/data/List/Files-118/Documentation.pdf
    olds = jerrums(autogen,n)
    b_to_test = 0
    parent = [ [x] for x in range(0,n)]
    while len(olds)>0 and b_to_test < n:
        # keep going
        # find all reachable from b_to_test under olds
        # run a BFS from b_to_test to all
        mappers = find_prop(b_to_test, olds, n)
        # generate the Schreier generators
        olds = jerrums(schreier_generator(mappers,olds),n)
        for x in mappers:
            if x is not b_to_test:
                parent[x][0]=b_to_test
        b_to_test += 1
    return parent
# Script to test

#print(lazy_SGS([Permutation([1,0,2,3]),Permutation([1,0,3,2])],4))
